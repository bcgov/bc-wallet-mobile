package com.bcsccore.storage

import android.content.Context
import android.util.Base64
import android.util.Log
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKeys
import java.security.SecureRandom
import javax.crypto.SecretKeyFactory
import javax.crypto.spec.PBEKeySpec

/**
 * Native-compatible PIN storage that matches ias-android's AndroidKeyChainService.
 *
 * Key differences from the original bcsc-core implementation:
 * 1. Uses EncryptedSharedPreferences (not regular SharedPreferences)
 * 2. Uses dynamic file names based on alias (not a fixed file name)
 * 3. Uses "." separator for keys (not "_")
 * 4. Uses iteration count of 210,000 (not 600,000)
 * 5. Uses PBKDF2WithHmacSHA256 (not PBKDF2WithHmacSHA512)
 */
class NativeCompatiblePinStorage(
    private val context: Context,
) {
    companion object {
        private const val TAG = "NativeCompatiblePinStorage"

        // Native-compatible crypto parameters
        private const val SALT_LENGTH = 16
        private const val ITERATION_COUNT = 210000 // Match native (not 600000)
        private const val KEY_LENGTH_BYTES = 64
        private const val PREFERRED_ALGORITHM = "PBKDF2WithHmacSHA256" // Match native
        private const val FALLBACK_ALGORITHM = "PBKDF2withHmacSHA1"
    }

    /**
     * Sets the PIN secret in native-compatible EncryptedSharedPreferences.
     *
     * @param alias The alias/identifier for the PIN (typically account UUID)
     * @param plainTextPin The PIN in plain text
     * @param isAutoGenerated Whether the PIN was auto-generated (for device security) or user-created
     * @return The created PinSecret, or null if failed
     */
    fun setPin(
        alias: String,
        plainTextPin: String,
        isAutoGenerated: Boolean = false,
    ): NativePinSecret? =
        try {
            val salt = generateSalt()
            val algorithm = getAlgorithmToUse()
            val derivedKey = deriveKey(plainTextPin, salt, algorithm)

            val pinSecret =
                NativePinSecret(
                    id = alias,
                    salt = salt,
                    algorithmUsed = algorithm,
                    key = derivedKey,
                    isAutoGenerated = isAutoGenerated,
                )

            if (saveSecret(pinSecret)) {
                Log.d(TAG, "Successfully set PIN for alias: $alias (isAutoGenerated: $isAutoGenerated)")
                pinSecret
            } else {
                Log.e(TAG, "Failed to save PIN secret for alias: $alias")
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error setting PIN for alias: $alias", e)
            null
        }

    /**
     * Verifies a PIN against the stored secret.
     *
     * @param alias The alias/identifier for the PIN
     * @param plainTextPin The PIN to verify
     * @return true if PIN is correct, false otherwise
     */
    fun verifyPin(
        alias: String,
        plainTextPin: String,
    ): Boolean {
        return try {
            val secret = getSecret(alias) ?: return false
            val algorithm = secret.algorithmUsed ?: getAlgorithmToUse()
            val derivedKey = deriveKey(plainTextPin, secret.salt, algorithm)
            secret.key == derivedKey
        } catch (e: Exception) {
            Log.e(TAG, "Error verifying PIN for alias: $alias", e)
            false
        }
    }

    /**
     * Checks if a PIN is set for the given alias.
     */
    fun hasPin(alias: String): Boolean =
        try {
            getSecret(alias) != null
        } catch (e: Exception) {
            false
        }

    /**
     * Removes the PIN for the given alias.
     */
    fun removePin(alias: String): Boolean =
        try {
            val sharedPrefsFileName = alias.replace("/", "")
            val mainKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)

            val sharedPreferences =
                EncryptedSharedPreferences.create(
                    sharedPrefsFileName,
                    mainKeyAlias,
                    context,
                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM,
                )

            with(sharedPreferences.edit()) {
                remove("$alias.key")
                remove("$alias.salt")
                remove("$alias.algorithm")
                remove("$alias.isAutoGenerated")
                apply()
            }

            Log.d(TAG, "Successfully removed PIN for alias: $alias")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error removing PIN for alias: $alias", e)
            false
        }

    /**
     * Gets the stored secret for the given alias.
     * Uses EncryptedSharedPreferences with native-compatible format.
     */
    private fun getSecret(alias: String): NativePinSecret? =
        try {
            val sharedPrefsFileName = alias.replace("/", "")
            val mainKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)

            val sharedPreferences =
                EncryptedSharedPreferences.create(
                    sharedPrefsFileName,
                    mainKeyAlias,
                    context,
                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM,
                )

            val key = sharedPreferences.getString("$alias.key", null)
            val saltEncoded = sharedPreferences.getString("$alias.salt", null)
            val algorithm = sharedPreferences.getString("$alias.algorithm", null)
            val isAutoGenerated = sharedPreferences.getBoolean("$alias.isAutoGenerated", false)

            if (key != null && saltEncoded != null) {
                val salt = Base64.decode(saltEncoded, Base64.NO_WRAP)
                NativePinSecret(alias, salt, algorithm, key, isAutoGenerated)
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting secret for alias: $alias", e)
            null
        }

    /**
     * Saves the PIN secret to EncryptedSharedPreferences.
     * Uses native-compatible key format with "." separator.
     */
    private fun saveSecret(pinSecret: NativePinSecret): Boolean =
        try {
            val sharedPrefsFileName = pinSecret.id.replace("/", "")
            val mainKeyAlias = MasterKeys.getOrCreate(MasterKeys.AES256_GCM_SPEC)

            val sharedPreferences =
                EncryptedSharedPreferences.create(
                    sharedPrefsFileName,
                    mainKeyAlias,
                    context,
                    EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
                    EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM,
                )

            val saltEncoded = Base64.encodeToString(pinSecret.salt, Base64.NO_WRAP)

            with(sharedPreferences.edit()) {
                putString("${pinSecret.id}.key", pinSecret.key)
                putString("${pinSecret.id}.salt", saltEncoded)
                putString("${pinSecret.id}.algorithm", pinSecret.algorithmUsed)
                putBoolean("${pinSecret.id}.isAutoGenerated", pinSecret.isAutoGenerated)
                apply()
            }

            true
        } catch (e: Exception) {
            Log.e(TAG, "Error saving secret", e)
            false
        }

    /**
     * Generates a cryptographically secure random salt.
     */
    private fun generateSalt(): ByteArray {
        val secureRandom = SecureRandom()
        return ByteArray(SALT_LENGTH).also { secureRandom.nextBytes(it) }
    }

    /**
     * Gets the algorithm to use for key derivation.
     * Prefers PBKDF2WithHmacSHA256 to match native.
     */
    private fun getAlgorithmToUse(): String =
        try {
            SecretKeyFactory.getInstance(PREFERRED_ALGORITHM)
            PREFERRED_ALGORITHM
        } catch (e: Exception) {
            try {
                SecretKeyFactory.getInstance(FALLBACK_ALGORITHM)
                FALLBACK_ALGORITHM
            } catch (e2: Exception) {
                PREFERRED_ALGORITHM // Return preferred anyway, will fail at derivation
            }
        }

    /**
     * Derives a key from the PIN using PBKDF2.
     * Uses native-compatible parameters.
     */
    private fun deriveKey(
        plainTextPin: String,
        salt: ByteArray,
        algorithm: String,
    ): String {
        val keySpec =
            PBEKeySpec(
                plainTextPin.toCharArray(),
                salt,
                ITERATION_COUNT,
                KEY_LENGTH_BYTES * 8,
            )
        val keyFactory = SecretKeyFactory.getInstance(algorithm)
        val derivedKey = keyFactory.generateSecret(keySpec)

        // Native uses contentToString() for the key representation
        return derivedKey.encoded.contentToString()
    }

    /**
     * Attempts to migrate from old bcsc-core PIN format to native format.
     *
     * Note: Due to different PBKDF2 parameters (iteration count and algorithm),
     * we cannot directly migrate the derived keys. Users will need to re-enter
     * their PIN after migration.
     *
     * This method checks if an old-format PIN exists and logs a warning.
     */
    fun checkForOldFormatPin(alias: String): Boolean {
        try {
            val oldPrefs = context.getSharedPreferences("bcsc_pin_secrets", Context.MODE_PRIVATE)
            val oldKey = oldPrefs.getString("${alias}_key", null)

            if (oldKey != null) {
                Log.w(
                    TAG,
                    "Found old-format PIN for alias: $alias. " +
                        "PIN will need to be re-entered due to incompatible crypto parameters.",
                )
                return true
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error checking for old format PIN", e)
        }
        return false
    }

    /**
     * Removes old-format PIN storage after user has set a new PIN.
     */
    fun removeOldFormatPin(alias: String): Boolean =
        try {
            val oldPrefs = context.getSharedPreferences("bcsc_pin_secrets", Context.MODE_PRIVATE)
            with(oldPrefs.edit()) {
                remove("${alias}_key")
                remove("${alias}_salt")
                remove("${alias}_algorithm")
                remove("${alias}_isAutoGenerated")
                apply()
            }
            Log.d(TAG, "Removed old-format PIN for alias: $alias")
            true
        } catch (e: Exception) {
            Log.e(TAG, "Error removing old format PIN", e)
            false
        }

    /**
     * Gets the PIN hash (PBKDF2 derived key) for use as an Askar wallet key.
     *
     * @param alias The alias/identifier for the PIN
     * @return Pair of (hash, isAutoGenerated) or null if not found
     */
    fun getPinHash(alias: String): Pair<String, Boolean>? =
        try {
            val secret = getSecret(alias)
            if (secret != null) {
                Pair(secret.key, secret.isAutoGenerated)
            } else {
                null
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error getting PIN hash for alias: $alias", e)
            null
        }

    /**
     * Checks if the stored PIN was auto-generated (for device security) or user-created.
     *
     * @param alias The alias/identifier for the PIN
     * @return true if PIN was auto-generated, false if user-created or not found
     */
    fun isPinAutoGenerated(alias: String): Boolean =
        try {
            val secret = getSecret(alias)
            secret?.isAutoGenerated ?: false
        } catch (e: Exception) {
            Log.e(TAG, "Error checking if PIN is auto-generated for alias: $alias", e)
            false
        }
}

/**
 * Native-compatible PinSecret data class.
 */
data class NativePinSecret(
    val id: String,
    val salt: ByteArray,
    val algorithmUsed: String?,
    val key: String,
    val isAutoGenerated: Boolean = false,
) {
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (javaClass != other?.javaClass) return false

        other as NativePinSecret

        if (id != other.id) return false
        if (!salt.contentEquals(other.salt)) return false
        if (algorithmUsed != other.algorithmUsed) return false
        if (key != other.key) return false
        if (isAutoGenerated != other.isAutoGenerated) return false

        return true
    }

    override fun hashCode(): Int {
        var result = id.hashCode()
        result = 31 * result + salt.contentHashCode()
        result = 31 * result + (algorithmUsed?.hashCode() ?: 0)
        result = 31 * result + key.hashCode()
        result = 31 * result + isAutoGenerated.hashCode()
        return result
    }
}
