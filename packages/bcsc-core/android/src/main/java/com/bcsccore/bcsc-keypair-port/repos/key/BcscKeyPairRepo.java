package com.bcsccore.keypair.repos.key;

import android.os.Build;
import android.os.Build.VERSION;
import android.os.Build.VERSION_CODES;
import android.security.keystore.KeyGenParameterSpec;
import android.security.keystore.KeyProperties;
import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.bcsccore.keypair.core.utils.SimpleLog;
import com.bcsccore.keypair.core.exceptions.AlertKey;
import com.bcsccore.keypair.core.models.BcscKeyPair;
import com.bcsccore.keypair.core.exceptions.BcscException;
import com.bcsccore.keypair.core.exceptions.KeypairGenerationException;
import com.bcsccore.keypair.core.models.KeyPairInfo;
import com.bcsccore.keypair.core.interfaces.KeyPairInfoSource;
import com.bcsccore.keypair.core.interfaces.BcscKeyPairSource;
import com.nimbusds.jose.JWSAlgorithm;
import com.nimbusds.jose.JWSHeader;
import com.nimbusds.jose.crypto.RSASSASigner;
import com.nimbusds.jose.jwk.JWK;
import com.nimbusds.jose.jwk.RSAKey;
import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import java.security.InvalidAlgorithmParameterException;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.KeyStore;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.UnrecoverableEntryException;
import java.security.interfaces.RSAPublicKey;
import java.util.HashMap;
import java.util.Locale;

/**
 * Android KeyStore implementation of BcscKeyPairSource.
 * 
 * This class manages RSA key pairs stored in Android's hardware-backed KeyStore.
 * Key features:
 * - Generates 4096-bit RSA keys with RS512 signing
 * - Hardware security module backing when available
 * - Automatic key rotation and cleanup
 * - JWT signing with private keys
 * 
 * IMPORTANT: Keys generated by this class are:
 * - Tied to the specific app installation
 * - Bound to the app's signing certificate
 * - Cannot be exported or shared between apps
 */
public class BcscKeyPairRepo implements BcscKeyPairSource {

  private static final String RSA_ALIAS_PREFIX = "rsa";
  private static final String ALIAS_RSA = RSA_ALIAS_PREFIX + "1";
  private static final String KEYSTORE_TYPE = "AndroidKeyStore";
  private static final String TAG = "BcscKeyPairRepo";

  @NonNull
  private final KeyPairInfoSource keyPairInfoSource;

  /**
   * Create a new BcscKeyPairRepo.
   * @param keyPairInfoSource the source for storing key pair metadata
   */
  public BcscKeyPairRepo(@NonNull KeyPairInfoSource keyPairInfoSource) {
    this.keyPairInfoSource = keyPairInfoSource;
  }

  @Override
  public boolean isAvailable() {
    try {
      loadAndroidKeyStore();
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  @NonNull
  public BcscKeyPair getCurrentBcscKeyPair() throws BcscException {
    try {
      KeyStore keyStore = loadAndroidKeyStore();

      KeyPairInfo info = getNewestKeyPairInfo(keyPairInfoSource.getKeyPairInfo());

      if (info == null) {
        info = new KeyPairInfo(ALIAS_RSA, System.currentTimeMillis());
        keyPairInfoSource.saveKeyPairInfo(info);
      }

      if (!keyStore.containsAlias(info.getAlias())) {
        generateKeyPair(info.getAlias());
      }

      final KeyPair keyPair = getKeyPair(keyStore, info.getAlias());
      SimpleLog.d(TAG, "Current active key pair " + info.getAlias());
      return new BcscKeyPair(keyPair, info);
    } catch (Exception e) {
      throw new KeypairGenerationException(e.getMessage());
    }
  }

  @Nullable
  @Override
  public BcscKeyPair getBcscKeyPair(@NonNull String kid) throws BcscException {
    try {
      KeyStore keyStore = loadAndroidKeyStore();

      if (!keyStore.containsAlias(kid)) {
        return null;
      }

      KeyPairInfo info = keyPairInfoSource.getKeyPairInfo(kid);
      if (info == null) {
        info = new KeyPairInfo(kid, System.currentTimeMillis());
        keyPairInfoSource.saveKeyPairInfo(info);
      }

      final KeyPair keyPair = getKeyPair(keyStore, kid);
      return new BcscKeyPair(keyPair, info);
    } catch (Exception e) {
      return null;
    }
  }

  @NonNull
  @Override
  public BcscKeyPair getNewBcscKeyPair() throws BcscException {
    try {
      KeyStore keyStore = loadAndroidKeyStore();

      KeyPairInfo info = getNewestKeyPairInfo(keyPairInfoSource.getKeyPairInfo());

      if (info == null) {
        info = new KeyPairInfo(ALIAS_RSA, System.currentTimeMillis());
        keyPairInfoSource.saveKeyPairInfo(info);
      }

      int id = Integer.parseInt(info.getAlias().replaceAll("\\D+", ""));

      id += 1;

      final String alias = String.format(Locale.ROOT, "%s%d", RSA_ALIAS_PREFIX, id);

      final KeyPairInfo newInfo = new KeyPairInfo(alias, System.currentTimeMillis());
      keyPairInfoSource.saveKeyPairInfo(newInfo);

      generateKeyPair(alias);
      final KeyPair keyPair = getKeyPair(keyStore, alias);
      SimpleLog.d(TAG, "Generated new key pair " + alias);
      return new BcscKeyPair(keyPair, newInfo);
    } catch (Exception e) {
      throw new KeypairGenerationException(e.getMessage());
    }
  }

  @Override
  public void deleteBcscKeyPair(@NonNull String alias) throws BcscException {
    SimpleLog.d(TAG, "Deleting key pair " + alias);
    keyPairInfoSource.deleteKeyPairInfo(alias);
    boolean success = deleteKeyEntry(alias);
    if (!success) {
      throw new BcscException(AlertKey.ERR_108_UNABLE_TO_DELETE_KEY_PAIR);
    }
  }

  @Override
  public void cleanUpBcscKeyPairs() throws BcscException {
    KeyPairInfo info = getOldestKeyPairInfo(keyPairInfoSource.getKeyPairInfo());

    if (info == null) {
      return;
    }
    SimpleLog.d(TAG, "Cleaning up key pair " + info.getAlias());
    keyPairInfoSource.deleteKeyPairInfo(info.getAlias());
    boolean success = deleteKeyEntry(info.getAlias());
    if (!success) {
      throw new BcscException(AlertKey.ERR_108_UNABLE_TO_DELETE_KEY_PAIR);
    }
  }

  @Nullable
  private KeyPairInfo getNewestKeyPairInfo(HashMap<String, KeyPairInfo> infoMap) {
    KeyPairInfo info = null;
    for (KeyPairInfo keyPairInfo : infoMap.values()) {
      if (info == null) {
        info = keyPairInfo;
      } else {
        if (keyPairInfo.getCreatedAt() > info.getCreatedAt()) {
          info = keyPairInfo;
        }
      }
    }
    return info;
  }

  @Nullable
  private KeyPairInfo getOldestKeyPairInfo(HashMap<String, KeyPairInfo> infoMap) {

    if (infoMap.size() < 3) {
      return null;
    }

    String alias = null;
    long currentOldKeyTime = System.currentTimeMillis();
    for (KeyPairInfo keyPairInfo : infoMap.values()) {
      if (keyPairInfo.getCreatedAt() < currentOldKeyTime) {
        currentOldKeyTime = keyPairInfo.getCreatedAt();
        alias = keyPairInfo.getAlias();
      }
    }
    return infoMap.get(alias);
  }

  @NonNull
  private KeyStore loadAndroidKeyStore() throws Exception {
    KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);
    keyStore.load(null);
    return keyStore;
  }

  /**
   * Generate a new RSA key pair in Android KeyStore.
   * Creates a 4096-bit RSA key with SHA-512 digest for signing.
   * 
   * @param alias the alias to store the key pair under
   */
  private void generateKeyPair(String alias) {
    try {

      final KeyGenParameterSpec.Builder builder = new KeyGenParameterSpec.Builder(
          alias,
          KeyProperties.PURPOSE_SIGN
              | KeyProperties.PURPOSE_VERIFY
              | KeyProperties.PURPOSE_ENCRYPT
              | KeyProperties.PURPOSE_DECRYPT
      );

      builder.setDigests(KeyProperties.DIGEST_SHA512)
          .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_RSA_PKCS1)
          .setKeySize(4096)
          .setSignaturePaddings(KeyProperties.SIGNATURE_PADDING_RSA_PKCS1);

      if (VERSION.SDK_INT >= VERSION_CODES.N) {
        builder.setInvalidatedByBiometricEnrollment(false);
      }

      final KeyGenParameterSpec spec = builder.build();

      final KeyPairGenerator gen = KeyPairGenerator.getInstance(
          KeyProperties.KEY_ALGORITHM_RSA, "AndroidKeyStore");
      gen.initialize(spec);
      gen.generateKeyPair();
    } catch (InvalidAlgorithmParameterException
        | NoSuchAlgorithmException
        | NoSuchProviderException e) {
      SimpleLog.e(TAG, "Failed to generate key pair", e);
    }
  }

  private boolean deleteKeyEntry(String alias) {
    try {
      KeyStore keyStore = loadAndroidKeyStore();
      keyStore.deleteEntry(alias);
      return true;
    } catch (Exception e) {
      return false;
    }
  }

  @NonNull
  @Override
  public JWK convertBcscKeyPairToJWK(@NonNull BcscKeyPair bcscKeyPair) {
    return new RSAKey.Builder((RSAPublicKey) bcscKeyPair.getKeyPair().getPublic())
        .keyID(bcscKeyPair.getKeyInfo().getAlias())
        .build();
  }

  @Override
  @NonNull
  public String signAndSerializeClaimsSet(@NonNull JWTClaimsSet claimsSet) throws BcscException {
    try {
      SignedJWT signedJWT = signClaimsSet(claimsSet);
      return signedJWT.serialize();
    } catch (Exception e) {
      throw new BcscException(AlertKey.ERR_207_UNABLE_TO_SIGN_CLAIMS_SET, e.getMessage());
    }
  }

  /**
   * This is the core signing method where attestation signing happens.
   * 
   * Signs a JWT claims set using the current key pair's private key.
   * Uses RS512 algorithm (RSA signature with SHA-512 hash).
   * 
   * @param claimsSet the JWT claims to sign
   * @return the signed JWT
   * @throws BcscException if signing fails
   */
  @Override
  @NonNull
  public SignedJWT signClaimsSet(@NonNull JWTClaimsSet claimsSet) throws BcscException {
    try {
      SignedJWT signedJWT = new SignedJWT(new JWSHeader(JWSAlgorithm.RS512), claimsSet);
      signedJWT.sign(new RSASSASigner(getCurrentBcscKeyPair().getKeyPair().getPrivate()));
      return signedJWT;
    } catch (Exception e) {
      throw new BcscException(AlertKey.ERR_207_UNABLE_TO_SIGN_CLAIMS_SET, e.getMessage());
    }
  }

  @NonNull
  private KeyPair getKeyPair(@NonNull KeyStore keyStore, @NonNull String kid)
      throws UnrecoverableEntryException, NoSuchAlgorithmException, KeyStoreException {
    if (Build.VERSION.SDK_INT <= VERSION_CODES.O_MR1) {
      final PrivateKey privateKey = (PrivateKey) keyStore.getKey(kid, null);
      final PublicKey publicKey = keyStore.getCertificate(kid).getPublicKey();
      return new KeyPair(publicKey, privateKey);
    } else {
      final KeyStore.PrivateKeyEntry privateKeyEntry =
          (KeyStore.PrivateKeyEntry) keyStore.getEntry(kid, null);
      return new KeyPair(
          privateKeyEntry.getCertificate().getPublicKey(),
          privateKeyEntry.getPrivateKey()
      );
    }
  }

}
