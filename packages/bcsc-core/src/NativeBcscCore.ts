import type { TurboModule } from 'react-native';
import { TurboModuleRegistry } from 'react-native';

export type LoginChallenge = {
  /** Audience - the client ID */
  aud: string;
  /** Issuer URL */
  iss: string;
  /** The challenge code */
  bcsc_challenge: string;
  /** Expiration timestamp (Unix seconds) */
  exp: number;
  /** Client display name */
  bcsc_client_name: string;
  /** Issued at timestamp (Unix seconds) */
  iat: number;
  /** JWT ID */
  jti: string;
};

export type LoginChallengeResult = {
  /** Whether the JWT signature was verified against the issuer's public key */
  verified: boolean;
  /** The decoded JWT claims */
  claims: LoginChallenge;
};

// Re-declaring PrivateKeyInfo and KeyPair here to avoid import issues from index.ts
// Ideally, these would be in a shared types file if not for TurboModule limitations.
export type PrivateKeyInfo = {
  id: string;
  keyType?: string;
  keySize?: number;
  created?: number; // Timestamp
};

export type KeyPair = {
  id: string;
  public: string;
  private?: string;
  privateKeyAvailable: string;
};

// Assuming TokenType enum is defined in index.ts and will be used by the JS side.
// For the native spec, we might just expect a number if not importing.
export type NativeToken = {
  id: string;
  type: number; // Corresponds to TokenType rawValue
  token: string;
  created: number; // Timestamp
  expiry?: number | null; // Timestamp or null
};

export type JWK = {
  kty: string;
  e: string;
  kid: string;
  alg: string;
  n: string;
};

export type JWTClaims = {
  iss: string;
  aud: string;
  sub: string;
  iat: number;
  exp: number;
  [key: string]: any;
};

export enum AccountSecurityMethod {
  PinNoDeviceAuth = 'app_pin_no_device_authn',
  PinWithDeviceAuth = 'app_pin_has_device_authn',
  DeviceAuth = 'device_authentication',
}

export enum BiometricType {
  None = 'none',
  TouchID = 'touchID',
  FaceID = 'faceID',
  OpticID = 'opticID',
}

export type PINVerificationResult = {
  success: boolean;
  locked: boolean;
  remainingTime: number;
  walletKey?: string; // PBKDF2 hash of PIN, only present on success
  title?: string;
  message?: string;
};

export type AccountLockStatus = {
  locked: boolean;
  remainingTime: number;
};

export type PINSetupResult = {
  success: boolean;
  walletKey: string; // PBKDF2 hash of PIN for Askar wallet
  isAutoGenerated: boolean;
};

export type DeviceSecurityUnlockResult = {
  success: boolean;
  walletKey?: string; // PBKDF2 hash, only present on success
  migrated?: boolean; // true if this was a v3 user migration (PIN was just created)
};

export type NativeAddress = {
  streetAddress?: string;
  locality?: string;
  postalCode?: string;
  country?: string;
  region?: string;
};

export enum BCSCCardProcess {
  BCSCPhoto = 'IDIM L3 Remote BCSC Photo Identity Verification',
  BCSCNonPhoto = 'IDIM L3 Remote BCSC Non-Photo Identity Verification',
  NonBCSC = 'IDIM L3 Remote Non-BCSC Identity Verification',
  None = 'N/A',
}

export type NativeAuthorizationRequest = {
  // Device/user codes
  deviceCode?: string;
  userCode?: string;

  // User identity info
  birthdate?: number; // Unix timestamp
  csn?: string; // Card Serial Number
  verifiedEmail?: string;

  // User profile info
  firstName?: string;
  lastName?: string;
  middleNames?: string;
  address?: NativeAddress;

  // Request metadata
  status?: number; // RequestStatus enum value
  method?: number; // AuthorizationMethodType enum value
  audience?: string;
  scope?: string;
  redirectURI?: string;
  requestedAt?: number; // Unix timestamp
  expiry?: number; // Unix timestamp
  authorizationExpiry?: number; // Unix timestamp

  // Verification options
  verificationOptions?: string;
  verificationURIVideo?: string;

  // BackCheck verification
  backCheckSubmittedDate?: number; // Unix timestamp
  backCheckVerificationId?: string;

  // Evidence upload
  evidenceUploadURI?: string;

  // Identification process type
  cardProcess?: BCSCCardProcess;
};

export type NativeAccount = {
  readonly id: string;
  issuer: string;
  clientID: string;
  securityMethod: AccountSecurityMethod;
  displayName?: string;
  didPostNicknameToServer?: boolean;
  nickname?: string;
  failedAttemptCount?: number;
  // lastAttemptDate?: number; // Timestamp
  // Penalties are not directly included as it's a computed property
  // with complex structure
};

export interface Spec extends TurboModule {
  getAllKeys(): Promise<PrivateKeyInfo[]>;
  getKeyPair(label: string): Promise<KeyPair>;
  getToken(tokenType: number): Promise<NativeToken | null>;

  /**
   * Saves a token to secure native storage.
   * @param tokenType 0=Access, 1=Refresh, 2=Registration
   * @param token The token string to store
   * @param expiry Unix timestamp in seconds when token expires (or -1 for no expiry)
   * @returns true if saved successfully
   */
  setToken(tokenType: number, token: string, expiry: number): Promise<boolean>;

  /**
   * Deletes a token from secure native storage.
   * @param tokenType 0=Access, 1=Refresh, 2=Registration
   * @returns true if deleted successfully
   */
  deleteToken(tokenType: number): Promise<boolean>;
  setIssuer(issuer: string): Promise<boolean>;
  getAccount(): Promise<NativeAccount | null>;
  setAccount(account: Omit<NativeAccount, 'id'>): Promise<void>;
  getRefreshTokenRequestBody(issuer: string, clientID: string, refreshToken: string): Promise<string | null>;
  signPairingCode(
    code: string,
    issuer: string,
    clientID: string,
    fcmDeviceToken: string,
    deviceToken: string | null
  ): Promise<string | null>;
  getDeviceId(): Promise<string>;
  getDynamicClientRegistrationBody(
    fcmDeviceToken: string,
    deviceToken: string | null,
    attestation: string | null,
    nickname?: string | null
  ): Promise<string | null>;
  getDeviceCodeRequestBody(
    deviceCode: string,
    clientId: string,
    issuer: string,
    confirmationCode: string
  ): Promise<string | null>;
  decodePayload(jweString: string): Promise<string>;
  decodeLoginChallenge(jwt: string, key: JWK | null): Promise<LoginChallengeResult>;
  createPreVerificationJWT(deviceCode: string, clientID: string): Promise<string>;
  createQuickLoginJWT(
    accessToken: string,
    clientId: string,
    issuer: string,
    clientRefId: string,
    key: JWK,
    fcmDeviceToken: string,
    deviceToken: string | null
  ): Promise<string>;
  hashBase64(base64: string): Promise<string>;
  removeAccount(): Promise<void>;
  createSignedJWT(claims: JWTClaims): Promise<string>;

  // PIN Authentication Methods
  setPIN(pin: string): Promise<PINSetupResult>;
  verifyPIN(pin: string): Promise<PINVerificationResult>;
  deletePIN(): Promise<boolean>;
  hasPINSet(): Promise<boolean>;

  // Device Authentication Methods
  performDeviceAuthentication(reason?: string): Promise<boolean>;
  canPerformDeviceAuthentication(): Promise<boolean>;
  getAvailableBiometricType(): Promise<BiometricType>;
  canPerformBiometricAuthentication(): Promise<boolean>;

  // Account Security Methods
  setAccountSecurityMethod(securityMethod: AccountSecurityMethod): Promise<boolean>;
  getAccountSecurityMethod(): Promise<AccountSecurityMethod>;
  isAccountLocked(): Promise<AccountLockStatus>;

  // Device Security Methods
  setupDeviceSecurity(): Promise<PINSetupResult>;
  unlockWithDeviceSecurity(reason?: string): Promise<DeviceSecurityUnlockResult>;
  isPINAutoGenerated(): Promise<boolean>;

  // Authorization Request Storage Methods
  /**
   * Gets the stored authorization request data.
   * Reads from the authorization_request file in Application Support (iOS)
   * or encrypted storage (Android), compatible with v3 native app storage.
   * @returns The authorization request data or null if not found
   */
  getAuthorizationRequest(): Promise<NativeAuthorizationRequest | null>;

  /**
   * Saves authorization request data to storage.
   * Writes to the authorization_request file in Application Support (iOS)
   * or encrypted storage (Android), compatible with v3 native app storage.
   * @param data The authorization request data to save
   * @returns true if saved successfully
   */
  setAuthorizationRequest(data: NativeAuthorizationRequest): Promise<boolean>;

  /**
   * Deletes the stored authorization request data.
   * @returns true if deleted successfully (or if it didn't exist)
   */
  deleteAuthorizationRequest(): Promise<boolean>;

  // Account Flags Storage Methods
  /**
   * Gets account flags from native storage.
   * iOS: Reads from account_flag file in Application Support
   * Android: Reads from account-specific SharedPreferences
   * Compatible with v3 native app storage for rollback support.
   * @returns Object containing account flags (isEmailVerified, userSkippedEmailVerification, emailAddress, etc.)
   */
  getAccountFlags(): Promise<Record<string, unknown>>;

  /**
   * Sets account flags in native storage.
   * iOS: Writes to account_flag file in Application Support
   * Android: Writes to account-specific SharedPreferences
   * Compatible with v3 native app storage for rollback support.
   * @param flags Object containing flags to set (merges with existing)
   * @returns true if saved successfully
   */
  setAccountFlags(flags: Record<string, unknown>): Promise<boolean>;

  /**
   * Deletes all account flags from native storage.
   * @returns true if deleted successfully (or if they didn't exist)
   */
  deleteAccountFlags(): Promise<boolean>;

  // Evidence Metadata Storage Methods
  /**
   * Gets evidence metadata from native storage.
   * iOS: Reads from evidence_metadata file in Application Support (matches EvidenceMetadataRequestStorageSource)
   * Android: Reads from EvidenceRepository SharedPreferences storage
   * Compatible with v3 native app storage for rollback support.
   * @returns Array of evidence metadata objects
   */
  getEvidenceMetadata(): Promise<Record<string, unknown>[]>;

  /**
   * Sets evidence metadata in native storage.
   * iOS: Writes to evidence_metadata file in Application Support (matches EvidenceMetadataRequestStorageSource)
   * Android: Writes to EvidenceRepository SharedPreferences storage
   * Compatible with v3 native app storage for rollback support.
   * @param evidence Array of evidence metadata objects to save
   * @returns true if saved successfully
   */
  setEvidenceMetadata(evidence: Record<string, unknown>[]): Promise<boolean>;

  /**
   * Deletes all evidence metadata from native storage.
   * @returns true if deleted successfully (or if they didn't exist)
   */
  deleteEvidenceMetadata(): Promise<boolean>;

  // Credential Storage Methods
  /**
   * Gets credential information from native storage.
   * iOS: Stored within ClientRegistration in secure keychain
   * Android: Stored within Provider → ClientRegistration in secure storage
   * Compatible with v3 native app storage for verification state detection.
   * @returns The credential object or null if not found
   */
  getCredential(): Promise<Record<string, unknown> | null>;

  /**
   * Sets credential information in native storage.
   * iOS: Stores within ClientRegistration in secure keychain
   * Android: Stores within Provider → ClientRegistration in secure storage
   * Compatible with v3 native app storage for verification state detection.
   * @param credential The credential object to save
   * @returns true if saved successfully
   */
  setCredential(credential: Record<string, unknown>): Promise<boolean>;

  /**
   * Deletes credential information from native storage.
   * This effectively marks the account as not verified
   * @returns true if deleted successfully (or if it didn't exist)
   */
  deleteCredential(): Promise<boolean>;

  /**
   * Checks if a credential exists without retrieving it.
   * Useful for quick verification status checks
   * @returns true if credential exists, false otherwise
   */
  hasCredential(): Promise<boolean>;
  showLocalNotification(title: string, message: string): Promise<void>;
}

export default TurboModuleRegistry.getEnforcing<Spec>('BcscCore');
