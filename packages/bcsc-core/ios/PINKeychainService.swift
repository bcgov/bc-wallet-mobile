//
//  PINKeychainService.swift
//  bcsc-core
//
//  Created by BC Wallet Mobile on 2024-11-24.
//

import Foundation
import Security

enum PINKeychainServiceError: Error, LocalizedError {
  case secretAlreadyExist
  case secretNotFound
  case unhandledError(OSStatus)

  var errorDescription: String? {
    switch self {
    case .secretAlreadyExist:
      return "PIN secret already exists"
    case .secretNotFound:
      return "PIN secret not found"
    case let .unhandledError(status):
      return "Keychain error: \(status)"
    }
  }
}

protocol PINKeychainServiceProtocol {
  /// Save or update secret in keychain based on secret.id
  func storeSecret(_ secret: PINSecret) -> PINKeychainServiceError?
  /// Retrieve secret with ID
  func getSecret(_ id: String) -> PINSecret?
  /// Delete secret with ID
  func deleteSecret(_ id: String) -> PINKeychainServiceError?
}

struct PINKeychainService: PINKeychainServiceProtocol {
  private let pinEncoding = String.Encoding.utf8

  func storeSecret(_ secret: PINSecret) -> PINKeychainServiceError? {
    // Delete any existing items first to handle partial state (log but don't fail on error)
    if let deleteError = deleteSecret(secret.id) {
      print("[PINKeychainService] Note: deleteSecret before storeSecret returned: \(deleteError.localizedDescription)")
    }

    var status: OSStatus = errSecSuccess

    // Store key
    status = addItemIfNotExist(
      label: getSecretKeyLabel(secret.id),
      value: secret.key.data(using: pinEncoding)!
    )
    if status != errSecSuccess, status != errSecDuplicateItem {
      return .unhandledError(status)
    }

    // Store salt
    status = addItemIfNotExist(
      label: getSecretSaltLabel(secret.id),
      value: secret.salt
    )
    if status != errSecSuccess, status != errSecDuplicateItem {
      return .unhandledError(status)
    }

    // Store isAutoGenerated flag
    let autoGeneratedValue = secret.isAutoGenerated ? "1" : "0"
    status = addItemIfNotExist(
      label: getSecretAutoGeneratedLabel(secret.id),
      value: autoGeneratedValue.data(using: pinEncoding)!
    )

    if status == errSecSuccess {
      return nil
    } else if status == errSecDuplicateItem {
      return .secretAlreadyExist
    } else {
      return .unhandledError(status)
    }
  }

  func getSecret(_ id: String) -> PINSecret? {
    guard let key = loadItem(label: getSecretKeyLabel(id)),
          let salt = loadItem(label: getSecretSaltLabel(id))
    else {
      return nil
    }

    // Load isAutoGenerated flag (default to false for backward compatibility)
    var isAutoGenerated = false
    if let autoGeneratedData = loadItem(label: getSecretAutoGeneratedLabel(id)),
       let autoGeneratedString = String(data: autoGeneratedData, encoding: pinEncoding)
    {
      isAutoGenerated = autoGeneratedString == "1"
    }

    let secret = PINSecret(
      salt: salt,
      key: String(data: key, encoding: pinEncoding) ?? "",
      id: id,
      isAutoGenerated: isAutoGenerated
    )

    return secret
  }

  func deleteSecret(_ id: String) -> PINKeychainServiceError? {
    var status: OSStatus = errSecSuccess
    var anyDeleted = false

    // Delete salt
    status = deleteItem(label: getSecretSaltLabel(id))
    if status == errSecSuccess {
      anyDeleted = true
    } else if status != errSecItemNotFound {
      return .unhandledError(status)
    }

    // Delete key
    status = deleteItem(label: getSecretKeyLabel(id))
    if status == errSecSuccess {
      anyDeleted = true
    } else if status != errSecItemNotFound {
      return .unhandledError(status)
    }

    // Delete isAutoGenerated flag
    status = deleteItem(label: getSecretAutoGeneratedLabel(id))
    if status == errSecSuccess {
      anyDeleted = true
    } else if status != errSecItemNotFound {
      return .unhandledError(status)
    }

    // Return secretNotFound only if nothing was deleted
    return anyDeleted ? nil : .secretNotFound
  }
}

// MARK: - Private methods

extension PINKeychainService {
  /// Return label representing keychain item for secret's key
  private func getSecretKeyLabel(_ secretID: String) -> String {
    return "\(secretID).key"
  }

  /// Return label representing keychain item for secret's salt
  private func getSecretSaltLabel(_ secretID: String) -> String {
    return "\(secretID).salt"
  }

  /// Return label representing keychain item for secret's isAutoGenerated flag
  private func getSecretAutoGeneratedLabel(_ secretID: String) -> String {
    return "\(secretID).isAutoGenerated"
  }

  private func addItemIfNotExist(label: String, value: Data) -> OSStatus {
    // Check if item exists first
    if loadItem(label: label) != nil {
      return errSecDuplicateItem
    }

    let query: [String: Any] = [
      kSecClass as String: kSecClassGenericPassword,
      kSecAttrAccount as String: label, // Use account for unique identification
      kSecAttrLabel as String: label, // Keep label for human readability
      kSecValueData as String: value,
      kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly,
    ]

    return SecItemAdd(query as CFDictionary, nil)
  }

  private func loadItem(label: String) -> Data? {
    let query: [String: Any] = [
      kSecClass as String: kSecClassGenericPassword,
      kSecAttrAccount as String: label, // Match by account, not label
      kSecMatchLimit as String: kSecMatchLimitOne,
      kSecReturnData as String: true,
    ]

    var item: CFTypeRef?
    let status = SecItemCopyMatching(query as CFDictionary, &item)

    guard status == errSecSuccess else {
      return nil
    }

    return item as? Data
  }

  private func deleteItem(label: String) -> OSStatus {
    let query: [String: Any] = [
      kSecClass as String: kSecClassGenericPassword,
      kSecAttrAccount as String: label, // Match by account, not label
    ]

    return SecItemDelete(query as CFDictionary)
  }
}
