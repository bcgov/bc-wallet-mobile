//
//  PINService.swift
//  bcsc-core
//
//  Created by BC Wallet Mobile on 2024-11-24.
//

import CommonCrypto
import Foundation

protocol PINServiceProtocol {
  func setPIN(issuer: String, accountID: String, pin: String, isAutoGenerated: Bool) throws -> String
  func verifyPINAndGetHash(issuer: String, accountID: String, pin: String) -> String?
  func deletePIN(issuer: String, accountID: String) throws
  func getPINHash(issuer: String, accountID: String) -> (hash: String, isAutoGenerated: Bool)?
  func isPINAutoGenerated(issuer: String, accountID: String) -> Bool
}

struct PINService: PINServiceProtocol {
  private let cryptoPolicy: PINCryptoPolicyProtocol
  private let cryptoWrapper: CommonCryptoWrapperProtocol
  private let keychainService: PINKeychainServiceProtocol

  init(
    cryptoPolicy: PINCryptoPolicyProtocol = PINCryptoPolicy(),
    cryptoWrapper: CommonCryptoWrapperProtocol = CommonCryptoWrapper(),
    keychainService: PINKeychainServiceProtocol = PINKeychainService()
  ) {
    self.cryptoPolicy = cryptoPolicy
    self.cryptoWrapper = cryptoWrapper
    self.keychainService = keychainService
  }

  /// Sets PIN and returns the PBKDF2 hash (wallet key)
  @discardableResult
  func setPIN(issuer: String, accountID: String, pin: String, isAutoGenerated: Bool = false) throws -> String {
    let secretID = PINSecret.composeID(issuer: issuer, accountID: accountID)

    // Always try to delete any existing secret first (log but don't fail on error)
    if let deleteError = keychainService.deleteSecret(secretID) {
      print("[PINService] Note: deleteSecret before setPIN returned: \(deleteError.localizedDescription)")
    }

    // Generate random salt
    let salt = Data(SecureRandom.nextBytes(count: cryptoPolicy.getSaltLength()))

    let encodedPIN = deriveKey(pin: pin, salt: salt)

    // Save encoded PIN in keychain
    let secret = PINSecret(
      salt: salt,
      key: encodedPIN,
      issuer: issuer,
      accountID: accountID,
      isAutoGenerated: isAutoGenerated
    )

    if let error = keychainService.storeSecret(secret) {
      throw error
    }

    return encodedPIN
  }

  /// Verifies PIN and returns the hash if successful, nil otherwise
  func verifyPINAndGetHash(issuer: String, accountID: String, pin: String) -> String? {
    guard let record = keychainService.getSecret(PINSecret.composeID(issuer: issuer, accountID: accountID)) else {
      return nil
    }

    let encodedPINToCompare = deriveKey(pin: pin, salt: record.salt)

    if record.key == encodedPINToCompare {
      return record.key
    }
    return nil
  }

  func deletePIN(issuer: String, accountID: String) throws {
    let secretID = PINSecret.composeID(issuer: issuer, accountID: accountID)

    if keychainService.getSecret(secretID) != nil {
      if let error = keychainService.deleteSecret(secretID) {
        throw error
      }
    } else {
      throw PINKeychainServiceError.secretNotFound
    }
  }

  /// Gets the stored PIN hash (PBKDF2 derived key) for use as an Askar wallet key
  func getPINHash(issuer: String, accountID: String) -> (hash: String, isAutoGenerated: Bool)? {
    let secretID = PINSecret.composeID(issuer: issuer, accountID: accountID)
    guard let record = keychainService.getSecret(secretID) else {
      return nil
    }
    return (hash: record.key, isAutoGenerated: record.isAutoGenerated)
  }

  /// Checks if the stored PIN was auto-generated (for device security) or user-created
  func isPINAutoGenerated(issuer: String, accountID: String) -> Bool {
    let secretID = PINSecret.composeID(issuer: issuer, accountID: accountID)
    guard let record = keychainService.getSecret(secretID) else {
      return false
    }
    return record.isAutoGenerated
  }
}

// MARK: - Private methods

extension PINService {
  /// Encode PIN with salt and get derived key
  private func deriveKey(pin: String, salt: Data) -> String {
    // Hash the password using PBKDF2 with HMAC SHA-512
    let derivedKey = cryptoWrapper.deriveKey(
      password: pin,
      salt: salt.arrayOfBytes(),
      prf: CCPseudoRandomAlgorithm(kCCPRFHmacAlgSHA512),
      rounds: UInt32(cryptoPolicy.getIterationCount()),
      derivedKeyLength: UInt(cryptoPolicy.getKeyLength())
    )
    return Data(derivedKey).base64EncodedString()
  }
}
