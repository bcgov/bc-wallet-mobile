diff --git a/build/utils/getRevocationRegistries.js b/build/utils/getRevocationRegistries.js
index 659e85e5d206ae9ba291383325403f922b2e9e1d..533750be7cfc1d04a9e6eb3edc8771e37b743b02 100644
--- a/build/utils/getRevocationRegistries.js
+++ b/build/utils/getRevocationRegistries.js
@@ -33,6 +33,7 @@ async function getRevocationRegistriesForRequest(agentContext, proofRequest, sel
                 nonRevoked: (_b = proofRequest.requested_predicates[referent].non_revoked) !== null && _b !== void 0 ? _b : proofRequest.non_revoked,
             });
         }
+        const revocationRegistryPromises = []
         for (const { referent, selectedCredential, nonRevoked, type } of referentCredentials) {
             if (!selectedCredential.credentialInfo) {
                 throw new core_1.AriesFrameworkError(`Credential for referent '${referent} does not have credential info for revocation state creation`);
@@ -55,38 +56,43 @@ async function getRevocationRegistriesForRequest(agentContext, proofRequest, sel
                     .resolve(services_1.AnonCredsRegistryService)
                     .getRegistryForIdentifier(agentContext, revocationRegistryId);
                 // Fetch revocation registry definition if not in revocation registries list yet
-                if (!revocationRegistries[revocationRegistryId]) {
-                    const { revocationRegistryDefinition, resolutionMetadata } = await registry.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
-                    if (!revocationRegistryDefinition) {
-                        throw new core_1.AriesFrameworkError(`Could not retrieve revocation registry definition for revocation registry ${revocationRegistryId}: ${resolutionMetadata.message}`);
+                const getRevocationRegistry = async () => {
+                    if (!revocationRegistries[revocationRegistryId]) {
+                        const { revocationRegistryDefinition, resolutionMetadata } = await registry.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
+                        if (!revocationRegistryDefinition) {
+                            throw new core_1.AriesFrameworkError(`Could not retrieve revocation registry definition for revocation registry ${revocationRegistryId}: ${resolutionMetadata.message}`);
+                        }
+                        const { tailsLocation, tailsHash } = revocationRegistryDefinition.value;
+                        const { tailsFilePath } = await (0, tails_1.downloadTailsFile)(agentContext, tailsLocation, tailsHash);
+                        // const tails = await this.indyUtilitiesService.downloadTails(tailsHash, tailsLocation)
+                        revocationRegistries[revocationRegistryId] = {
+                            definition: revocationRegistryDefinition,
+                            tailsFilePath,
+                            revocationStatusLists: {},
+                        };
                     }
-                    const { tailsLocation, tailsHash } = revocationRegistryDefinition.value;
-                    const { tailsFilePath } = await (0, tails_1.downloadTailsFile)(agentContext, tailsLocation, tailsHash);
-                    // const tails = await this.indyUtilitiesService.downloadTails(tailsHash, tailsLocation)
-                    revocationRegistries[revocationRegistryId] = {
-                        definition: revocationRegistryDefinition,
-                        tailsFilePath,
-                        revocationStatusLists: {},
-                    };
-                }
-                // In most cases we will have a timestamp, but if it's not defined, we use the nonRevoked.to value
-                const timestampToFetch = timestamp !== null && timestamp !== void 0 ? timestamp : nonRevoked.to;
-                // Fetch revocation status list if we don't already have a revocation status list for the given timestamp
-                if (!revocationRegistries[revocationRegistryId].revocationStatusLists[timestampToFetch]) {
-                    const { revocationStatusList, resolutionMetadata: statusListResolutionMetadata } = await registry.getRevocationStatusList(agentContext, revocationRegistryId, timestampToFetch);
-                    if (!revocationStatusList) {
-                        throw new core_1.AriesFrameworkError(`Could not retrieve revocation status list for revocation registry ${revocationRegistryId}: ${statusListResolutionMetadata.message}`);
-                    }
-                    revocationRegistries[revocationRegistryId].revocationStatusLists[revocationStatusList.timestamp] =
-                        revocationStatusList;
-                    // If we don't have a timestamp on the selected credential, we set it to the timestamp of the revocation status list
-                    // this way we know which revocation status list to use when creating the proof.
-                    if (!timestamp) {
-                        updatedSelectedCredentials = Object.assign(Object.assign({}, updatedSelectedCredentials), { [type]: Object.assign(Object.assign({}, updatedSelectedCredentials[type]), { [referent]: Object.assign(Object.assign({}, updatedSelectedCredentials[type][referent]), { timestamp: revocationStatusList.timestamp }) }) });
+                    // In most cases we will have a timestamp, but if it's not defined, we use the nonRevoked.to value
+                    const timestampToFetch = timestamp !== null && timestamp !== void 0 ? timestamp : nonRevoked.to;
+                    // Fetch revocation status list if we don't already have a revocation status list for the given timestamp
+                    if (!revocationRegistries[revocationRegistryId].revocationStatusLists[timestampToFetch]) {
+                        const { revocationStatusList, resolutionMetadata: statusListResolutionMetadata } = await registry.getRevocationStatusList(agentContext, revocationRegistryId, timestampToFetch);
+                        if (!revocationStatusList) {
+                            throw new core_1.AriesFrameworkError(`Could not retrieve revocation status list for revocation registry ${revocationRegistryId}: ${statusListResolutionMetadata.message}`);
+                        }
+                        revocationRegistries[revocationRegistryId].revocationStatusLists[revocationStatusList.timestamp] =
+                            revocationStatusList;
+                        // If we don't have a timestamp on the selected credential, we set it to the timestamp of the revocation status list
+                        // this way we know which revocation status list to use when creating the proof.
+                        if (!timestamp) {
+                            updatedSelectedCredentials = Object.assign(Object.assign({}, updatedSelectedCredentials), { [type]: Object.assign(Object.assign({}, updatedSelectedCredentials[type]), { [referent]: Object.assign(Object.assign({}, updatedSelectedCredentials[type][referent]), { timestamp: revocationStatusList.timestamp }) }) });
+                        }
                     }
                 }
+                revocationRegistryPromises.push(getRevocationRegistry())
             }
         }
+        // await all revocation registry statuses asynchronously
+        await Promise.all(revocationRegistryPromises)
         agentContext.config.logger.debug(`Retrieved revocation registries for proof request`, {
             revocationRegistries,
         });
@@ -104,6 +110,7 @@ async function getRevocationRegistriesForRequest(agentContext, proofRequest, sel
 exports.getRevocationRegistriesForRequest = getRevocationRegistriesForRequest;
 async function getRevocationRegistriesForProof(agentContext, proof) {
     const revocationRegistries = {};
+    const revocationRegistryPromises = [];
     for (const identifier of proof.identifiers) {
         const revocationRegistryId = identifier.rev_reg_id;
         const timestamp = identifier.timestamp;
@@ -114,25 +121,29 @@ async function getRevocationRegistriesForProof(agentContext, proof) {
             .resolve(services_1.AnonCredsRegistryService)
             .getRegistryForIdentifier(agentContext, revocationRegistryId);
         // Fetch revocation registry definition if not already fetched
-        if (!revocationRegistries[revocationRegistryId]) {
-            const { revocationRegistryDefinition, resolutionMetadata } = await registry.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
-            if (!revocationRegistryDefinition) {
-                throw new core_1.AriesFrameworkError(`Could not retrieve revocation registry definition for revocation registry ${revocationRegistryId}: ${resolutionMetadata.message}`);
+        const getRevocationRegistry = async () => {
+            if (!revocationRegistries[revocationRegistryId]) {
+                const { revocationRegistryDefinition, resolutionMetadata } = await registry.getRevocationRegistryDefinition(agentContext, revocationRegistryId);
+                if (!revocationRegistryDefinition) {
+                    throw new core_1.AriesFrameworkError(`Could not retrieve revocation registry definition for revocation registry ${revocationRegistryId}: ${resolutionMetadata.message}`);
+                }
+                revocationRegistries[revocationRegistryId] = {
+                    definition: revocationRegistryDefinition,
+                    revocationStatusLists: {},
+                };
             }
-            revocationRegistries[revocationRegistryId] = {
-                definition: revocationRegistryDefinition,
-                revocationStatusLists: {},
-            };
-        }
-        // Fetch revocation status list by timestamp if not already fetched
-        if (!revocationRegistries[revocationRegistryId].revocationStatusLists[timestamp]) {
-            const { revocationStatusList, resolutionMetadata: statusListResolutionMetadata } = await registry.getRevocationStatusList(agentContext, revocationRegistryId, timestamp);
-            if (!revocationStatusList) {
-                throw new core_1.AriesFrameworkError(`Could not retrieve revocation status list for revocation registry ${revocationRegistryId}: ${statusListResolutionMetadata.message}`);
+            // Fetch revocation status list by timestamp if not already fetched
+            if (!revocationRegistries[revocationRegistryId].revocationStatusLists[timestamp]) {
+                const { revocationStatusList, resolutionMetadata: statusListResolutionMetadata } = await registry.getRevocationStatusList(agentContext, revocationRegistryId, timestamp);
+                if (!revocationStatusList) {
+                    throw new core_1.AriesFrameworkError(`Could not retrieve revocation status list for revocation registry ${revocationRegistryId}: ${statusListResolutionMetadata.message}`);
+                }
+                revocationRegistries[revocationRegistryId].revocationStatusLists[timestamp] = revocationStatusList;
             }
-            revocationRegistries[revocationRegistryId].revocationStatusLists[timestamp] = revocationStatusList;
         }
+        revocationRegistryPromises.push(getRevocationRegistry())
     }
+    await Promise.all(revocationRegistryPromises)
     return revocationRegistries;
 }
 exports.getRevocationRegistriesForProof = getRevocationRegistriesForProof;
