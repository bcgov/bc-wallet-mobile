diff --git a/android/src/main/java/com/mrousavy/camera/core/CameraSession+Configuration.kt b/android/src/main/java/com/mrousavy/camera/core/CameraSession+Configuration.kt
index 1e9c0def6444656112c34856f70eddda982a6b55..a9d6582ebd74ef815fd1c70781e04a3f03c59314 100644
--- a/android/src/main/java/com/mrousavy/camera/core/CameraSession+Configuration.kt
+++ b/android/src/main/java/com/mrousavy/camera/core/CameraSession+Configuration.kt
@@ -75,11 +75,42 @@ internal fun CameraSession.configureOutputs(configuration: CameraConfiguration)
       }
 
       if (format != null) {
-        // Preview will follow video size as it's size & aspect ratio, or photo- if video is disabled.
-        val targetSize = if (videoConfig != null) format.videoSize else format.photoSize
+        // When CodeScanner is active, Preview MUST use videoSize (same as CodeScanner)
+        // to ensure both use cases get the same aspect ratio → same sensor crop → same FOV.
+        // Without this, Preview may get e.g. photoSize (4:3 → 1600x1200) while CodeScanner
+        // gets videoSize (16:9 → 1920x1080), causing misaligned barcode overlays.
+        val codeScannerConfig = configuration.codeScanner as? CameraConfiguration.Output.Enabled<CameraConfiguration.CodeScanner>
+        val targetSize = if (codeScannerConfig != null) {
+          // CodeScanner always uses format.videoSize, so Preview must match
+          format.videoSize
+        } else if (videoConfig != null) {
+          format.videoSize
+        } else {
+          format.photoSize
+        }
+        Log.i(CameraSession.TAG, "Preview target size: ${targetSize} (codeScannerActive=${codeScannerConfig != null}, videoActive=${videoConfig != null})")
 
+        // Strictly filter Preview to matching aspect ratio to ensure Preview and
+        // ImageAnalysis/CodeScanner have the same FOV.
+        val targetAspect = targetSize.width.toFloat() / targetSize.height.toFloat()
         val previewResolutionSelector = ResolutionSelector.Builder()
-          .forSize(targetSize)
+          .setResolutionFilter { supportedSizes, _ ->
+            val tolerance = 0.05f
+            val aspectMatched = supportedSizes
+              .filter { Math.abs(it.width.toFloat() / it.height.toFloat() - targetAspect) < tolerance }
+              .sortedBy { Math.abs(it.width * it.height - targetSize.width * targetSize.height) }
+            if (aspectMatched.isNotEmpty()) {
+              Log.i(CameraSession.TAG, "Preview: filtered to ${aspectMatched.size} resolutions matching aspect ${targetAspect}: ${aspectMatched.take(3)}")
+              aspectMatched
+            } else {
+              // Fallback: sort by aspect ratio then size (original behavior)
+              Log.w(CameraSession.TAG, "Preview: no resolutions matching aspect ${targetAspect}, falling back to best-effort sort")
+              supportedSizes.sortedWith(compareBy(
+                { Math.abs(it.width.toFloat() / it.height.toFloat() - targetAspect) },
+                { Math.abs(it.width * it.height - targetSize.width * targetSize.height) }
+              ))
+            }
+          }
           .setAllowedResolutionMode(ResolutionSelector.PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION)
           .build()
         preview.setResolutionSelector(previewResolutionSelector)
@@ -220,7 +251,21 @@ internal fun CameraSession.configureOutputs(configuration: CameraConfiguration)
   val codeScannerConfig = configuration.codeScanner as? CameraConfiguration.Output.Enabled<CameraConfiguration.CodeScanner>
   if (codeScannerConfig != null) {
     Log.i(CameraSession.TAG, "Creating CodeScanner output...")
-    val analyzer = ImageAnalysis.Builder().build()
+    val analyzer = ImageAnalysis.Builder().also { analysis ->
+      // Use higher resolution for better barcode detection (especially dense PDF-417).
+      // Without this, CameraX defaults to ~640x480 which is insufficient for PDF-417 barcodes
+      // that need >=1156px width for reliable decoding per Google ML Kit documentation.
+      if (format != null) {
+        Log.i(CameraSession.TAG, "CodeScanner target size: ${format.videoSize}")
+        val resolutionSelector = ResolutionSelector.Builder()
+          .forSize(format.videoSize)
+          // Use same resolution mode as Preview so CameraX picks matching resolutions.
+          // Different modes can cause different actual resolutions → different FOV/crop → misaligned overlays.
+          .setAllowedResolutionMode(ResolutionSelector.PREFER_CAPTURE_RATE_OVER_HIGHER_RESOLUTION)
+          .build()
+        analysis.setResolutionSelector(resolutionSelector)
+      }
+    }.build()
     val pipeline = CodeScannerPipeline(codeScannerConfig.config, callback)
     analyzer.setAnalyzer(CameraQueues.analyzerExecutor, pipeline)
     codeScannerOutput = analyzer
@@ -280,6 +325,27 @@ internal suspend fun CameraSession.configureCamera(provider: ProcessCameraProvid
   // Bind it all together (must be on UI Thread)
   Log.i(CameraSession.TAG, "Binding ${useCases.size} use-cases...")
   camera = provider.bindToLifecycle(this, cameraSelector, *useCases.toTypedArray())
+
+  // Log actual resolved resolutions after binding (for debugging coordinate mapping)
+  val previewResInfo = previewOutput?.resolutionInfo
+  val codeScannerResInfo = codeScannerOutput?.resolutionInfo
+  val fpResInfo = frameProcessorOutput?.resolutionInfo
+  Log.i(CameraSession.TAG, "=== Post-bind resolution info ===")
+  if (previewResInfo != null) {
+    Log.i(CameraSession.TAG, "Preview ACTUAL resolution: ${previewResInfo.resolution.width}x${previewResInfo.resolution.height}, cropRect: ${previewResInfo.cropRect}")
+  } else {
+    Log.w(CameraSession.TAG, "Preview resolutionInfo is NULL (previewOutput=${if (previewOutput != null) "exists" else "null"})")
+  }
+  if (codeScannerResInfo != null) {
+    Log.i(CameraSession.TAG, "CodeScanner ACTUAL resolution: ${codeScannerResInfo.resolution.width}x${codeScannerResInfo.resolution.height}, cropRect: ${codeScannerResInfo.cropRect}")
+  } else {
+    Log.w(CameraSession.TAG, "CodeScanner resolutionInfo is NULL (codeScannerOutput=${if (codeScannerOutput != null) "exists" else "null"})")
+  }
+  if (fpResInfo != null) {
+    Log.i(CameraSession.TAG, "FrameProcessor ACTUAL resolution: ${fpResInfo.resolution.width}x${fpResInfo.resolution.height}, cropRect: ${fpResInfo.cropRect}")
+  }
+  Log.i(CameraSession.TAG, "=== End resolution info ===")
+
   // Notify callback
   callback.onInitialized()
 
diff --git a/android/src/main/java/com/mrousavy/camera/core/CodeScannerPipeline.kt b/android/src/main/java/com/mrousavy/camera/core/CodeScannerPipeline.kt
index 23d78d1350242c1d2497b732fd77b291b9e06c3a..769b5527824f093c248ee77295d2c70a0bf15924 100644
--- a/android/src/main/java/com/mrousavy/camera/core/CodeScannerPipeline.kt
+++ b/android/src/main/java/com/mrousavy/camera/core/CodeScannerPipeline.kt
@@ -23,6 +23,10 @@ class CodeScannerPipeline(val configuration: CameraConfiguration.CodeScanner, va
     val types = configuration.codeTypes.map { it.toBarcodeType() }
     val barcodeScannerOptions = BarcodeScannerOptions.Builder()
       .setBarcodeFormats(types[0], *types.toIntArray())
+      // Return all potential barcodes even if they cannot be fully decoded yet.
+      // This improves detection of partially visible or damaged barcodes (especially PDF-417)
+      // and enables earlier visual feedback to the user.
+      .enableAllPotentialBarcodes()
       .build()
     scanner = BarcodeScanning.getClient(barcodeScannerOptions)
   }
@@ -33,10 +37,36 @@ class CodeScannerPipeline(val configuration: CameraConfiguration.CodeScanner, va
 
     try {
       val inputImage = InputImage.fromMediaImage(image, imageProxy.imageInfo.rotationDegrees)
+      val rotation = imageProxy.imageInfo.rotationDegrees
+
+      // Debug: log image dimensions and cropRect for coordinate mapping verification
+      Log.d(TAG, "ImageProxy: ${imageProxy.width}x${imageProxy.height}, rotation=$rotation, " +
+        "InputImage: ${inputImage.width}x${inputImage.height}, cropRect=${imageProxy.cropRect}")
+
+      // Report frame dimensions in the ROTATED coordinate space to match ML Kit's
+      // boundingBox output. ML Kit internally applies the rotation for detection and
+      // returns bounding boxes in portrait/upright coordinates, but InputImage.width/height
+      // returns the ORIGINAL (unrotated) dimensions. We swap here so JS doesn't have to guess.
+      val frameWidth: Int
+      val frameHeight: Int
+      if (rotation == 90 || rotation == 270) {
+        frameWidth = inputImage.height   // swap for rotation
+        frameHeight = inputImage.width
+      } else {
+        frameWidth = inputImage.width
+        frameHeight = inputImage.height
+      }
+
       scanner.process(inputImage)
         .addOnSuccessListener { barcodes ->
           if (barcodes.isNotEmpty()) {
-            callback.onCodeScanned(barcodes, CodeScannerFrame(inputImage.width, inputImage.height))
+            // Debug: log each barcode's bounding box for coordinate mapping verification
+            barcodes.forEach { barcode ->
+              val bbox = barcode.boundingBox
+              Log.d(TAG, "Barcode[${barcode.format}]: bbox=(${bbox?.left},${bbox?.top},${bbox?.right},${bbox?.bottom}), " +
+                "size=${bbox?.width()}x${bbox?.height()}, frameReported=${frameWidth}x${frameHeight}, value=${barcode.rawValue?.take(30)}")
+            }
+            callback.onCodeScanned(barcodes, CodeScannerFrame(frameWidth, frameHeight))
           }
         }
         .addOnFailureListener { error ->
